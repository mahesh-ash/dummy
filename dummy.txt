// import { Loader2 } from 'lucide-react'
// import { useState, useEffect, useCallback } from 'react'

// import { Button } from '@/components/ui/button'
// import { useToast } from '@/hooks/use-toast'
// import { API_CONFIG } from '@/lib/constants'
// import { createAuthHeaders } from '@/lib/legacyUtils'

// interface TasksV2Props {
//   id: string
//   clientId: string
//   searchCode?: string
// }

// interface TasksV2Data {
//   [key: string]: unknown
// }

// const TasksV2: React.FC<TasksV2Props> = ({
//   id,
//   clientId,
//   searchCode
// }) => {
//   const { toast } = useToast()

//   // State management
//   const [loading, setLoading] = useState(false)
//   const [data, setData] = useState<TasksV2Data[]>([])
//   const [error, setError] = useState<string | null>(null)

//   // Fetch data from API
//   const fetchData = useCallback(async () => {
//     if (!clientId) return

//     setLoading(true)
//     setError(null)

//     try {
//       // TODO: Replace with actual API endpoint for tasks_v2
//       const response = await fetch(`${API_CONFIG.fullUrl}/reports/tasks_v2`, {
//         method: 'POST',
//         headers: createAuthHeaders(),
//         body: JSON.stringify({
//           clientId,
//           searchCode,
//           id
//         })
//       })

//       if (!response.ok) {
//         throw new Error(`HTTP error! status: ${response.status}`)
//       }

//       // Check if response has content and is JSON

//       const contentType = response.headers.get('content-type')

//       if (!contentType || !contentType.includes('application/json')) {

//         throw new Error('Invalid response format - expected JSON')

//       }

//       const responseText = await response.text()

//       if (!responseText.trim()) {

//         throw new Error('Empty response from server')

//       }

//       let result

//       try {

//         result = JSON.parse(responseText)

//       } catch (jsonError) {

//         throw new Error('Invalid JSON response from server')

//       }

//       if (result.success && result.data) {
//         setData(result.data)
//       } else {
//         throw new Error(result.message || 'Failed to fetch data')
//       }
//     } catch (err) {
//       const errorMsg = err instanceof Error ? err.message : 'Failed to fetch tasks_v2 data'
//       setError(errorMsg)
//       toast({
//         title: 'Error',
//         description: errorMsg,
//         variant: 'destructive'
//       })
//     } finally {
//       setLoading(false)
//     }
//   }, [clientId, searchCode, id, toast])

//   // Load data on component mount
//   useEffect(() => {
//     fetchData()
//   }, [fetchData])

//   if (loading) {
//     return (
//       <div className="flex items-center justify-center p-8">
//         <Loader2 className="h-8 w-8 animate-spin" />
//         <span className="ml-2">Loading TasksV2...</span>
//       </div>
//     )
//   }

//   return (
//     <div>
//       {error ? (
//           <div className="text-center py-8">
//             <p className="text-destructive mb-4">{error}</p>
//             <Button onClick={fetchData} variant="outline" size="sm">
//               Try Again
//             </Button>
//           </div>
//         ) : data.length === 0 ? (
//           <div className="text-center py-12">
//             <p className="text-muted-foreground text-lg mb-2">No data available</p>
//             <p className="text-muted-foreground text-sm">
//               Configure API endpoint to load data for tasks_v2
//             </p>
//           </div>
//         ) : (
//           <div className="space-y-4">
//             {/* TODO: Implement React-based UI components for this report */}
//             <div className="grid gap-4">
//               {data.slice(0, 10).map((item, _index) => (
//                 <div key={_index}>
//                   <pre className="text-sm text-muted-foreground overflow-auto">
//                     {JSON.stringify(item, null, 2)}
//                   </pre>
//                 </div>
//               ))}
//               {data.length > 10 && (
//                 <p className="text-sm text-muted-foreground text-center">
//                   Showing 10 of {data.length} items
//                 </p>
//               )}
//             </div>
//           </div>
//         )}
//     </div>
//   )
// }

// export default TasksV2

import React, { useEffect, useMemo, useState } from "react";
import DatePicker from "react-datepicker";
import "react-datepicker/dist/react-datepicker.css";
import { useToast } from "@/hooks/use-toast";
import { createAuthHeaders } from "@/lib/legacyUtils";
import { API_CONFIG } from "@/lib/constants";
import { prismStorage } from "@/lib/prismStorage";



type TaskItem = {
  taskId: string;
  taskName?: string;
  taskComment?: string;
  taskDate?: string; 
  taskAssignedName?: string;
  taskAssignedId?: string;
  taskType?: string;
  taskStatus?: string;
  contacts?: string[]; 
  
};

type ContactResult = {
  contact_cust_id: string;
  contact_name: string;
  account_name?: string;
};

type ReassignResult = {
  EMP_ID: string;
  reassign_name: string;
  role_name?: string;
};

export default function TasksWidget() {
  const { toast } = useToast();
  const [tasks, setTasks] = useState<TaskItem[]>([]);
  const [loading, setLoading] = useState(false);

  const [isModalOpen, setModalOpen] = useState(false);
  const [editTask, setEditTask] = useState<TaskItem | null>(null);


  const [subject, setSubject] = useState("");
  const [assignedTo, setAssignedTo] = useState(""); 
  const [taskType, setTaskType] = useState("");
  const [status, setStatus] = useState("");
  const [contacts, setContacts] = useState<string[]>([]);
  const [description, setDescription] = useState("");
  const [dueDate, setDueDate] = useState<Date | null>(new Date());
  const [timeStr, setTimeStr] = useState("10:00");

  const [contactQuery, setContactQuery] = useState("");
  const [contactOptions, setContactOptions] = useState<ContactResult[]>([]);
  const [contactLoading, setContactLoading] = useState(false);

  const [reassignQuery, setReassignQuery] = useState("");
  const [reassignOptions, setReassignOptions] = useState<ReassignResult[]>([]);
  const [reassignLoading, setReassignLoading] = useState(false);


  const [remindersByTask, setRemindersByTask] = useState<Record<string, { id?: string; date: string; time: string }[]>>({});


  async function fetchTasks() {
    setLoading(true);
    try {
      const summaryFilter = prismStorage.get("summaryFilter") || JSON.stringify({ filter: [] });
      const body = new URLSearchParams({ summaryFilter }).toString();
      const res = await fetch(`${API_CONFIG.baseUrl}/task/getTask`, {
        method: "POST",
        headers: createAuthHeaders({
          "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
          Accept: "application/json, text/javascript, */*; q=0.01",
        }),
        body,
        credentials: "include",
      });
      const data = await res.json();
      if (data?.status === 1) {
        setTasks(Array.isArray(data.data) ? data.data : []);
        const rmap: Record<string, { id?: string; date: string; time: string }[]> = {};
        (data.data || []).forEach((t: any) => {
          if (t.reminders && Array.isArray(t.reminders)) {
            rmap[t.taskId] = t.reminders.map((r: any) => {
              const dt = new Date(r.reminder);
              return {
                id: r.id,
                date: dt.toISOString().slice(0, 10),
                time: dt.toTimeString().slice(0, 5),
              };
            });
          }
        });
        setRemindersByTask(rmap);
      } else {
        setTasks([]);
      }
    } catch (err) {
      console.error("fetchTasks error", err);
      toast({ title: "Error", description: "Failed to fetch tasks" });
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    fetchTasks();
  }, []);


  async function handleAddTask() {
    try {
      if (!subject.trim()) {
        toast({ title: "Validation", description: "Subject required" });
        return;
      }
      const clienttimezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "";
      const dueDateStr = dueDate ? dueDate.toISOString().slice(0, 10) : "";
      const formattedDateTime = `${dueDateStr} ${timeStr}:00`;

      const payloadObj = {
        subject,
        dueDate: formattedDateTime,
        dueTime: timeStr,
        contacts,
        contactName: contacts || [],
        assignedTo,
        clienttimezone,
        status,
        taskType,
        taskComments: description,
        module_name: "Task",
        reminder: [],
        action: "Save",
      };

      console.log(assignedTo);

      const encoded = new URLSearchParams({ data: JSON.stringify(payloadObj) }).toString();

      const res = await fetch(`${API_CONFIG.baseUrl}/task/addTask`, {
        method: "POST",
        headers: createAuthHeaders({
          "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
          Accept: "application/json, text/javascript, */*; q=0.01",
        }),
        body: encoded,
        credentials: "include",
      });

      const data = await res.json();
      console.log(data.status);
      if (data?.status === 1) {
        toast({ title: "Success", description: "Task Added Successfully" });
        setModalOpen(false);
        resetForm();
        fetchTasks();
      } else {
        toast({ title: "Error", description: data?.message || "Failed to add task" });
      }
    } catch (err) {
      console.error("handleAddTask", err);
      toast({ title: "Error", description: "Failed to add task" });
    }
  }

  async function handleUpdateTask() {
    try {
      if (!editTask) return;
      const clienttimezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "";
      const dueDateStr = dueDate ? dueDate.toISOString().slice(0, 10) : "";
      const formattedDateTime = `${dueDateStr} ${timeStr}:00`;

      const payloadObj = {
        subject,
        dueDate: formattedDateTime,
        dueTime: timeStr,
        contacts,
        contactName: contacts || [],
        assignedTo,
        clienttimezone,
        status,
        taskType,
        taskComments: description,
        module_name: "Task",
        reminder: [],
        action: "Update",
        taskId: editTask.taskId,
      };

      const encoded = new URLSearchParams({ data: JSON.stringify(payloadObj) }).toString();

      const res = await fetch(`${API_CONFIG.baseUrl}/task/addTask`, {
        method: "POST",
        headers: createAuthHeaders({
          "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
          Accept: "application/json, text/javascript, */*; q=0.01",
        }),
        body: encoded,
        credentials: "include",
      });

      const data = await res.json();
      if (data?.status === 1) {
        toast({ title: "Success", description: "Task Updated Successfully" });
        setModalOpen(false);
        setEditTask(null);
        resetForm();
        fetchTasks();
      } else {
        toast({ title: "Error", description: data?.message || "Failed to update task" });
      }
    } catch (err) {
      console.error("handleUpdateTask", err);
      toast({ title: "Error", description: "Failed to update task" });
    }
  }

  function openEditModal(task: TaskItem) {
    setEditTask(task);
    setSubject(task.taskName || "");
    setDescription(task.taskComment || "");
    setAssignedTo(task.taskAssignedId || "");
    setTaskType(task.taskType || "");
    setStatus(task.taskStatus || "");
    if (task.taskDate) {
      const iso = task.taskDate.replace(" ", "T");
      const dt = new Date(iso);
      if (!isNaN(dt.getTime())) {
        setDueDate(dt);
        const hh = dt.getHours().toString().padStart(2, "0");
        const mm = dt.getMinutes().toString().padStart(2, "0");
        setTimeStr(`${hh}:${mm}`);
      } else {
        setDueDate(new Date());
        setTimeStr("10:00");
      }
    } else {
      setDueDate(new Date());
    }
    setContacts(task.contacts || []);
    setModalOpen(true);
  }

  async function deleteTask(taskId: string, originalTaskData: any) {
    try {
       const clienttimezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "";
      
      // Note: Make sure 'dueDate' and 'timeStr' are defined in the scope where this function runs.
      const dueDateStr = dueDate ? dueDate.toISOString().slice(0, 10) : "";
      const formattedDateTime = `${dueDateStr} ${timeStr}:00`;
      
      const payload = {
       subject: originalTaskData.subject,
        dueDate: formattedDateTime,
        dueTime: timeStr,
        contacts: originalTaskData.contacts || [],
        contactName: contacts || [],
        assignedTo: originalTaskData.taskAssignedId || "",
        clienttimezone,
        status: "Dismiss", 
        taskType: originalTaskData.taskType || "",
        taskComments:originalTaskData.taskComments || "",
        module_name: "Task",
        reminder: originalTaskData.reminder || [],
        action: "Dismiss",
        type: "Task",
        taskId: taskId,
      };
      const res = await fetch(`${API_CONFIG.baseUrl}/task/addTask`, {
        method: "POST",
        headers: createAuthHeaders({
          "Content-Type": "application/json",
          Accept: "application/json, text/javascript, */*; q=0.01",
        }),
        body: JSON.stringify(payload),
        credentials: "include",
      });
      const data = await res.json();
      if (data?.status === 1) {
        toast({ title: "Deleted", description: "Task Deleted Successfully" });
        fetchTasks();
      } else {
        toast({ title: "Error", description: data?.message || "Delete failed" });
      }
    } catch (err) {
      console.error("deleteTask", err);
      toast({ title: "Error", description: "Delete failed" });
    }
  }

  async function setDueDateForTask(taskId: string, dateStr: string, time: string) {
    try {
      const payload = new URLSearchParams({
        dueDate: `${dateStr} ${time}`,
        taskId,
      }).toString();
      const res = await fetch(`${API_CONFIG.baseUrl}/task/setDueDate`, {
        method: "POST",
        headers: createAuthHeaders({ "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }),
        body: payload,
        credentials: "include",
      });
      const data = await res.json();
      if (data?.status === 1) {
        toast({ title: "Success", description: "Due date updated" });
        fetchTasks();
      } else {
        toast({ title: "Error", description: data?.message || "Failed to update due date" });
      }
    } catch (err) {
      console.error("setDueDateForTask", err);
      toast({ title: "Error", description: "Failed to update due date" });
    }
  }
  async function addReminder(taskId: string, dateStr: string, time: string, indexer?: string) {
    try {
      const payload = new URLSearchParams({
        taskId,
        reminder: `${dateStr} ${time}`,
        taskName: "",
      }).toString();
      const res = await fetch(`${API_CONFIG.baseUrl}/task/addMultiReminder`, {
        method: "POST",
        headers: createAuthHeaders({ "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }),
        body: payload,
        credentials: "include",
      });
      const data = await res.json();
      if (data?.status === 1) {
        const rem = { id: data.reminder?.id || undefined, date: dateStr, time };
        setRemindersByTask((prev) => {
          const next = { ...prev };
          next[taskId] = next[taskId] ? [...next[taskId], rem] : [rem];
          return next;
        });
        toast({ title: "Success", description: "Reminder added" });
      } else {
        toast({ title: "Error", description: data?.message || "Failed to add reminder" });
      }
    } catch (err) {
      console.error("addReminder", err);
      toast({ title: "Error", description: "Failed to add reminder" });
    }
  }
  async function deleteReminder(taskId: string, reminderId?: string, index?: number) {
    try {
      const payload = new URLSearchParams({ reminderId: reminderId || "" }).toString();
      const res = await fetch(`${API_CONFIG.baseUrl}/task/deleteMultiReminder`, {
        method: "POST",
        headers: createAuthHeaders({ "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }),
        body: payload,
        credentials: "include",
      });
      const data = await res.json();
      if (data?.status === 1) {
        setRemindersByTask((prev) => {
          const next = { ...prev };
          if (!next[taskId]) return next;
          if (typeof index === "number") next[taskId] = next[taskId].filter((_, i) => i !== index);
          else next[taskId] = next[taskId].filter((r) => r.id !== reminderId);
          return next;
        });
        toast({ title: "Deleted", description: "Reminder deleted" });
      } else {
        toast({ title: "Error", description: data?.message || "Delete failed" });
      }
    } catch (err) {
      console.error("deleteReminder", err);
      toast({ title: "Error", description: "Delete failed" });
    }
  }

  async function setFollowUp(taskId: string, followupDateTime: string) {
    try {
      const payload = new URLSearchParams({
        taskId,
        followUpDate: followupDateTime,
      }).toString();
      const res = await fetch(`${API_CONFIG.baseUrl}/task/setTaskFollowUp`, {
        method: "POST",
        headers: createAuthHeaders({ "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }),
        body: payload,
        credentials: "include",
      });
      const data = await res.json();
      if (data?.status === 1) {
        toast({ title: "Success", description: "Follow-up set" });
        fetchTasks();
      } else {
        toast({ title: "Error", description: data?.message || "Failed to set follow-up" });
      }
    } catch (err) {
      console.error("setFollowUp", err);
      toast({ title: "Error", description: "Failed to set follow-up" });
    }
  }


  async function fetchContactOptions(query: string) {
    if (!query || query.length < 2) return setContactOptions([]);
    setContactLoading(true);
    try {
      const res = await fetch(`${API_CONFIG.baseUrl}/Summary/searchContact`, {
        method: "POST",
        headers: createAuthHeaders({ "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }),
        body: new URLSearchParams({ Name: query }).toString(),
        credentials: "include",
      });
      const data = await res.json();
      setContactOptions(data?.data || []);
    } catch (err) {
      console.error("fetchContactOptions", err);
      setContactOptions([]);
    } finally {
      setContactLoading(false);
    }
  }


  async function setTaskContact(taskId: string, contact: ContactResult) {
    try {
      const payload = new URLSearchParams({ taskId, contactId: contact.contact_cust_id }).toString();
      const res = await fetch(`${API_CONFIG.baseUrl}/task/taskSetContact`, {
        method: "POST",
        headers: createAuthHeaders({ "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }),
        body: payload,
        credentials: "include",
      });
      const data = await res.json();
      if (data?.status === 1) {
        toast({ title: "Success", description: "Contact added to task" });
        fetchTasks();
      } else {
        toast({ title: "Error", description: data?.message || "Failed to add contact" });
      }
    } catch (err) {
      console.error("setTaskContact", err);
      toast({ title: "Error", description: "Failed to add contact" });
    }
  }

  async function fetchReassignOptions(query: string) {
    if (!query || query.length < 2) return setReassignOptions([]);
    setReassignLoading(true);
    try {
      const res = await fetch(`${API_CONFIG.baseUrl}/task/searchReAssign`, {
        method: "POST",
        headers: createAuthHeaders({ "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }),
        body: new URLSearchParams({ Name: query }).toString(),
        credentials: "include",
      });
      const data = await res.json();
      setReassignOptions(data?.data || []);
    } catch (err) {
      console.error("fetchReassignOptions", err);
      setReassignOptions([]);
    } finally {
      setReassignLoading(false);
    }
  }

  async function setReassignTask(taskId: string, empId: string) {
    try {
      const payload = new URLSearchParams({ taskId, assignedTo: empId }).toString();
      const res = await fetch(`${API_CONFIG.baseUrl}/task/reAssign`, {
        method: "POST",
        headers: createAuthHeaders({ "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }),
        body: payload,
        credentials: "include",
      });
      const data = await res.json();
      if (data?.status === 1) {
        toast({ title: "Success", description: "Task reassigned" });
        fetchTasks();
      } else {
        toast({ title: "Error", description: data?.message || "Failed to reassign" });
      }
    } catch (err) {
      console.error("setReassignTask", err);
      toast({ title: "Error", description: "Failed to reassign" });
    }
  }


  function resetForm() {
    setSubject("");
    setAssignedTo("");
    setTaskType("");
    setStatus("");
    setContacts([]);
    setDescription("");
    setDueDate(new Date());
    setTimeStr("10:00");
  }


  const calcTimeDiff = (due: string | undefined) => {
    if (!due) return null;
    const dueDate = new Date(due);
    const now = new Date();
    const diffMs = dueDate.getTime() - now.getTime();
    const abs = Math.abs(diffMs);
    const days = Math.floor(abs / 86400000);
    const hours = Math.floor((abs % 86400000) / 3600000);
    const mins = Math.floor(((abs % 86400000) % 3600000) / 60000);
    if (days > 0) return `${days} Day(s)`;
    if (hours > 0) return `${hours} Hour(s)`;
    if (mins > 0) return `${mins} Min(s)`;
    return "0 Min(s)";
  };


  useEffect(() => {
    const id = setTimeout(() => fetchContactOptions(contactQuery), 300);
    return () => clearTimeout(id);
  }, [contactQuery]);

  useEffect(() => {
    const id = setTimeout(() => fetchReassignOptions(reassignQuery), 300);
    return () => clearTimeout(id);
  }, [reassignQuery]);

   const handleAssigneeChange = (e) => {
    setAssignedTo(e.target.value);
  };

   const availableContacts = [
    { 
      id: '10029', 
      name: 'David Roberts < droberts@angelogordon.com > Angelo Gordon & Co., L.P.' 
    },
    { 
      id: '10030', 
      name: 'Sarah Connor < sconnor@example.com > T-800 Corp.' 
    },
    { 
      id: '10031', 
      name: 'John Doe < jdoe@example.com > Generic Inc.' 
    }
  ];

   const handleContactChange = (e) => {
    // Get all selected options from the dropdown
    const selectedOptions = Array.from(e.target.selectedOptions);
    
    // Extract just the IDs for the 'contacts' state (["10029", "10030"])
    const selectedIds = selectedOptions.map(option => option.value);
    
    // Extract the full names for the 'contactName' state ([...full strings...])
    const selectedNames = selectedOptions.map(option => option.label);

    setContacts(selectedIds);
    setContactNames(selectedNames);
  };


  return (
    <div className="p-5">
      <div className="flex items-center justify-between">
        <h2 className="mb-3 text-xl font-semibold">Task List</h2>
        <button
          onClick={() => {
            setEditTask(null);
            resetForm();
            setModalOpen(true);
          }}
          className="rounded bg-blue-600 px-4 py-2 text-white"
        >
          Add Task
        </button>
      </div>

      {loading ? (
        <div>Loading...</div>
      ) : tasks.length === 0 ? (
        <p>No tasks found</p>
      ) : (
        <ul className="space-y-3">
          {tasks.map((t) => {
            const due = t.taskDate;
            return (
              <li key={t.taskId} className="rounded border bg-gray-50 p-3 shadow-sm relative">
                <h3 className="font-bold">{t.taskName}</h3>
                <p>{t.taskComment}</p>
                <p className="text-sm text-gray-600">
                  Due: {due} | Status: {t.taskStatus} | Assignee: {t.taskAssignedName}
                </p>

                {t.taskDate && (
                  <small className="absolute top-2 right-4 bg-red-500 text-white px-2 py-1 rounded text-xs">
                    {calcTimeDiff(t.taskDate)}
                  </small>
                )}

                <div className="mt-2 flex gap-3">
                  <button className="rounded bg-yellow-600 px-3 py-1 text-white" onClick={() => openEditModal(t)}>
                    Edit
                  </button>

                <button 
  className="rounded bg-red-600 px-3 py-1 text-white" 
  onClick={() => deleteTask(t.taskId, t)} // <-- Pass 't' as the second argument
>
  Delete
</button>

                  {/* <button
                    className="rounded bg-indigo-600 px-3 py-1 text-white"
                    onClick={() => {
                      (async () => {
                        try {
                          const payloadObj = {
                            subject: t.taskName,
                            dueDate: t.taskDate,
                            dueTime: t.taskDate ? t.taskDate.split(" ")[1].slice(0, 5) : "00:00",
                            contacts: t.contacts || [],
                            contactName: t.contacts || [],
                            assignedTo: t.taskAssignedId || "",
                            clienttimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                            status: "Dismiss",
                            taskType: t.taskType,
                            taskComments: t.taskComment,
                            module_name: "Task",
                            action: "Dismiss",
                            taskId: t.taskId,
                          };
                          const encoded = new URLSearchParams({ data: JSON.stringify(payloadObj) }).toString();
                          const res = await fetch(`${API_CONFIG.baseUrl}/task/addTask`, {
                            method: "POST",
                            headers: createAuthHeaders({
                              "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                            }),
                            body: encoded,
                            credentials: "include",
                          });
                          const d = await res.json();
                          if (d?.status === 1) {
                            toast({ title: "Success", description: d.message || "Dismissed" });
                            fetchTasks();
                          } else {
                            toast({ title: "Error", description: d.message || "Failed" });
                          }
                        } catch (err) {
                          console.error("dismiss err", err);
                          toast({ title: "Error", description: "Failed to dismiss" });
                        }
                      })();
                    }}
                  >
                    Dismiss
                  </button> */}
                </div>

                <div className="mt-3">
                  <div className="text-sm font-semibold">Reminders</div>
                  {(remindersByTask[t.taskId] || []).map((r, idx) => (
                    <div key={r.id || idx} className="flex items-center gap-2">
                      <div>{r.date} {r.time}</div>
                      <button
                        className="text-red-600 text-sm"
                        onClick={() => deleteReminder(t.taskId, r.id, idx)}
                      >
                        Delete
                      </button>
                    </div>
                  ))}
                  <div className="mt-2 flex gap-2">
                    <input type="date" className="rounded border p-1" id={`remdate-${t.taskId}`} />
                    <input type="time" className="rounded border p-1" id={`remtime-${t.taskId}`} />
                    <button
                      className="bg-green-600 text-white px-2 rounded"
                      onClick={() => {
                        const dInput = (document.getElementById(`remdate-${t.taskId}`) as HTMLInputElement).value;
                        const tm = (document.getElementById(`remtime-${t.taskId}`) as HTMLInputElement).value;
                        if (!dInput || !tm) {
                          toast({ title: "Error", description: "Please pick date & time" });
                          return;
                        }
                        addReminder(t.taskId, dInput, tm);
                      }}
                    >
                      Add
                    </button>
                  </div>
                </div>

                <div className="mt-3">
                  <div className="text-sm font-semibold">Add Contact to Task</div>
                  <div className="flex gap-2 items-center">
                    <input
                      type="text"
                      className="rounded border p-1"
                      placeholder="Search contact..."
                      value={contactQuery}
                      onChange={(e) => setContactQuery(e.target.value)}
                    />
                    <div>
                      {contactLoading ? <span>Loading...</span> : null}
                      {contactOptions.length > 0 && (
                        <ul className="bg-white border rounded mt-1 max-h-40 overflow-auto">
                          {contactOptions.map((c) => (
                            <li
                              key={c.contact_cust_id}
                              className="p-2 hover:bg-gray-100 cursor-pointer"
                              onClick={() => setTaskContact(t.taskId, c)}
                            >
                              <div className="font-semibold">{c.contact_name}</div>
                              <div className="text-xs text-gray-500">{c.account_name}</div>
                            </li>
                          ))}
                        </ul>
                      )}
                    </div>
                  </div>
                </div>

                {/* <div className="mt-3">
                  <div className="text-sm font-semibold">Reassign</div>
                  <div className="flex gap-2 items-center">
                    <input
                      type="text"
                      className="rounded border p-1"
                      placeholder="Search user..."
                      onChange={(e) => setReassignQuery(e.target.value)}
                    />
                    {reassignOptions.length > 0 && (
                      <div className="bg-white border rounded mt-1 max-h-40 overflow-auto">
                        {reassignOptions.map((r) => (
                          <div key={r.EMP_ID} className="p-2 hover:bg-gray-100 cursor-pointer" onClick={() => setReassignTask(t.taskId, r.EMP_ID)}>
                            <div className="font-semibold">{r.reassign_name}</div>
                            <div className="text-xs text-gray-500">{r.role_name}</div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div> */}
              </li>
            );
          })}
        </ul>
      )}

      {isModalOpen && (
        <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-40 z-40">
          <div className="relative w-[700px] rounded-lg bg-white p-5 z-50">
            <button className="absolute right-2 top-2" onClick={() => setModalOpen(false)}>X</button>
            <h2 className="mb-4 text-xl font-semibold">{editTask ? "Update Task" : "Add Task"}</h2>

            <label htmlFor="assignTo" className="block mb-2">Assign To</label>
      

      <select
        id="assignTo"
        value={assignedTo}
        onChange={handleAssigneeChange}
        className="mb-3 w-full rounded border p-2" // Use your existing CSS classes
      >

        <option value="">-- Select an assignee --</option>
        <option value="y00103">SABARISH Sanjeevi</option>
        <option value="y00143">Ajay Balu</option>
        
      </select>
      
      <p>Current Assignee: {assignedTo}</p>

            <label>Due Date</label>
            <DatePicker selected={dueDate} onChange={(d) => setDueDate(d)} className="mb-3 w-full rounded border p-2" />

            <label>Time</label>
            <input type="time" value={timeStr} onChange={(e) => setTimeStr(e.target.value)} className="mb-3 w-full rounded border p-2" />

            <label>Task Type</label>
            <select value={taskType} onChange={(e) => setTaskType(e.target.value)} className="mb-3 w-full rounded border p-2">
              <option value="">-- Select --</option>
              <option value="Call Back1">Call Back1</option>
              <option value="Action items">Action Items</option>
              <option value="Others">Others</option>
              <option value="Schedule Meeting">Schedule Meeting</option>
            </select>

            <label>Status</label>
            <select value={status} onChange={(e) => setStatus(e.target.value)} className="mb-3 w-full rounded border p-2">
              <option value="">-- Select --</option>
              <option value="Not Started">Not Started</option>
              <option value="Completed">Completed</option>
              <option value="In Progress">In Progress</option>
            </select>

            <label>Subject</label>
            <input type="text" value={subject} onChange={(e) => setSubject(e.target.value)} className="mb-3 w-full rounded border p-2" />

            <label htmlFor="contacts" className="block mb-2">Contacts</label>
      

      <select
        id="contacts"
        multiple
        value={contacts}
        onChange={handleContactChange}
        className="
          mb-3 w-full h-40
          rounded-lg border border-gray-300 bg-white
          text-gray-900 focus:ring-blue-500 focus:border-blue-500
          p-3 shadow-sm appearance-none
          overflow-y-auto
        "
        style={{ MozAppearance: 'none', WebkitAppearance: 'none' }}
      >

        {availableContacts.map((contact) => (
          <option key={contact.id} value={contact.id} className="p-2 hover:bg-blue-100">
            {contact.name} 
          </option>
        ))}
      </select>
      
  


            <label>Description</label>
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} rows={3} className="mb-3 w-full rounded border p-2" />

            <div className="mt-3">
              <button
                onClick={() => {
                  if (editTask) handleUpdateTask();
                  else handleAddTask();
                }}
                className="w-full rounded bg-green-600 py-2 text-white"
              >
                {editTask ? "Update Task" : "Save Task"}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
