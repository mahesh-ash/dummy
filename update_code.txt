import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import * as Dialog from '@radix-ui/react-dialog'
import {
  ChevronDownIcon,
  ChevronUpIcon,
  EyeIcon,
  PencilIcon,
  PlusIcon,
  Search,
  Trash2Icon,
  TrashIcon,
} from 'lucide-react'
import { MagnifyingGlassIcon, TableCellsIcon, FunnelIcon } from '@heroicons/react/24/outline'

import DatePicker from 'react-datepicker'

import { Input } from '@/components/ui/input'
import { useToast } from '@/hooks/use-toast'
import { API_CONFIG } from '@/lib/constants'
import { createAuthHeaders } from '@/lib/legacyUtils'
import { prismStorage } from '@/lib/prismStorage'

import 'react-datepicker/dist/react-datepicker.css'

import TimePicker from 'react-time-picker'
import 'react-time-picker/dist/TimePicker.css'
import 'react-clock/dist/Clock.css'
import {
  useReactTable,
  getCoreRowModel,
  getPaginationRowModel,
  getFilteredRowModel,
  flexRender,
  ColumnDef,
  VisibilityState,
} from '@tanstack/react-table'
import moment from 'moment-timezone'
import ReactUtils from '@/lib/reactUtils'
import {
  DataTableColumn,
  DataTableSettings,
  DrawDataTableCore,
  useDataTableState,
  UserTableSettings,
} from '@/lib/datatable-utils'
import DataTableFormatters from '@/lib/data-table-formatters'
import { TearsheetCommon } from '@/lib/tearsheet-common'
// import DataTable, { TableColumn } from 'react-data-table-component'
import { DataTable } from '@/components/ui/DataTable'

type TaskItem = {
  taskId: string
  taskName?: string
  taskComment?: string
  taskDate?: string
  taskAssignedName?: string[]
  taskAssignedId?: string[]
  taskType?: string
  taskStatus?: string
  contacts?: string[] // This is the structured array from the *full* details API
  contactName?: string[] | string // Can be array or single HTML string
  accountName?: string[] | string
  taskComments?: string
  reminder?: any[]
  // Add the new property found in the summary data
  contactList?: { contact_name: string; contact_id: string; account_name: string }[]
}

interface AssigneeOption {
  text?: string
  value?: string
  code?: string
  style?: string
  docName?: string | null
  docId?: string | null
}

interface ContactOption {
  text?: string
  value?: string
  code?: string
  style?: string
  docName?: string | null
  docId?: string | null
  account_name?: string
}
interface TaskOption {
  value: string
  text: string
}

interface TableSettingsResponse {
  status: number
  reasons: string
  settings: {
    column_def: string
    column_sort: string
    is_visible: number
  }
}

type UserTableSetting = {
  isDefault: string | boolean
  data: string
  checked: boolean
  title: string
}

type ClientConfigType = {
  columnHeadings: string[]
  columnIndices: string[]
  colsAlign: string[]
  tableSettings: { blockchk: boolean }[]
  defColSort: number
  defColSortType: string
  colsCnt: string[]
  // Assuming 'formatter' property exists in your original structure
  formatter: string[]
}

export interface DataTableProps {
  id?: string
  columns: TableColumn<unknown>[]
  dataSource: any[]
  loading?: boolean
  pagination?:
    | {
        pageSize?: number
        pageSizeOptions?: string[]
        showSizeChanger?: boolean
        showTotal?: (total: number, range: [number, number]) => string
        onChange?: (page: number, pageSize: number) => void
        onShowSizeChange?: (current: number, size: number) => void
      }
    | boolean
  rowSelection?: RowSelectionConfig
  scroll?: { x?: number | string; y?: number | string }
  size?: 'small' | 'middle' | 'large'
  bordered?: boolean
  showHeader?: boolean
  currentPanel?: any
}
export interface PaginationConfig {
  current?: number
  pageSize?: number
  total?: number
  showSizeChanger?: boolean
  showQuickJumper?: boolean
  showTotal?: (total: number, range: [number, number]) => React.ReactNode
  pageSizeOptions?: string[]
  onChange?: (page: number, pageSize: number) => void
  onShowSizeChange?: (current: number, size: number) => void
}

export interface RowSelectionConfig {
  type?: 'checkbox' | 'radio'
  selectedRowKeys?: React.Key[]
  onChange?: (selectedRowKeys: React.Key[], selectedRows: any[]) => void
  onSelect?: (record: any, selected: boolean, selectedRows: any[]) => void
  onSelectAll?: (selected: boolean, selectedRows: any[], changeRows: any[]) => void
  getCheckboxProps?: (record: any) => { disabled?: boolean }
}

interface DynamicTableConfigResponse {
  status: number
  message: string | null
  reason: string | null
  defColSort: string | null
  defColSortType: 'asc' | 'desc' | null
  reportName: string | null
  cols: string[] // dataIndex keys
  tabCols: (string | null)[]
  title: string[] // Column Headings
  data: any[] // The actual table data rows (can be typed more specifically if needed)
  recordsTotal?: number
  recordsFiltered?: number
  draw?: number
  colsCnt?: string[]
  formatter: string[]
}

interface TaskPayload {
  top: 'collapsed' | 'expanded' // Assuming these are the only options
  action: 'expanded' | 'collapsed' // Assuming these are the only options
  clienttimezone: string
  enablelink: boolean
  start: number
  length: number
  search: {
    value: string
    regex: boolean
  }
  order: Array<{
    column: number
    dir: 'asc' | 'desc'
    name: string
  }>
  columns: Array<{
    data: string
    name: string
    searchable: boolean
    orderable: boolean
    search: {
      value: string
      regex: boolean
    }
  }>
}

export default function TasksWidget() {
  const { toast } = useToast()
  const [tasks, setTasks] = useState<TaskItem[]>([])
  const [loading, setLoading] = useState(false)
  const [editTask, setEditTask] = useState<TaskItem | null>(null)
  const [subject, setSubject] = useState('')
  // const [assignedToIds, setAssignedTo] = useState('')
  const [assignedToIds, setAssignedTo] = useState('')
  const [assigneeList, setAssigneeList] = useState<AssigneeOption[]>([]) // This is the list used for the UI map
  const [taskType, setTaskType] = useState('')
  const [status, setStatus] = useState('')
  const [description, setDescription] = useState('')
  const [dueDate, setDueDate] = useState<Date | null>(new Date())
  // const [timeStr, setTimeStr] = useState('10:00')
  const [timeStr, setTimeStr] = useState<string | null>('')
  const [query, setQuery] = useState('')
  const [assigneeResults, setAssigneeResults] = useState<AssigneeOption[]>([])
  const [loadingSearch, setLoadingSearch] = useState(false)
  const [isOpen, setIsOpen] = useState(false)
  const [selectedIndex, setSelectedIndex] = useState(-1)
  const [isModalOpen, setModalOpen] = useState(false)
  const inputRef = useRef(null)
  // const [assignedToName, setAssignedToName] = useState('')

  // const [assigneeList, setAssigneeList] = useState<Assignee[]>([]);

  const [isViewModalOpen, setIsViewModalOpen] = useState(false)
  const [selectedTask, setSelectedTask] = useState<TaskItem | null>(null)

  //  const [assignedToIds, setAssignedToIds] = useState<string[]>([]);
  const [assignedToNames, setAssignedToNames] = useState<string[]>([])
  const [contactNames, setContactNames] = useState<string[]>([])
  const [contacts, setContacts] = useState<string[]>([])
  const [contactQuery, setContactQuery] = useState('')
  const [contactResults, setContactResults] = useState<ContactOption[]>([])
  const [loadingContacts, setLoadingContacts] = useState(false)
  const [isContactResultsOpen, setIsContactResultsOpen] = useState(false)

  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false)
  const [taskToDeleteData, setTaskToDeleteData] = useState(null)

  const [showAllTasks, setShowAllTasks] = useState(false)

  const [taskOptions, setTaskOptions] = useState<TaskOption[]>([])
  const [isLoadingOptions, setIsLoadingOptions] = useState(false)

  const [statusOptions, setStatusOptions] = useState<TaskOption[]>([])
  const [isLoadingStatusOptions, setIsLoadingStatusOptions] = useState(false)

  const [formKey, setFormKey] = useState(0)

  const tasksToShow = showAllTasks ? tasks : tasks.slice(0, 3)
  const hasMoreTasks = tasks.length > 3

  const [isLoading, setIsLoading] = useState(false)

  const [sortConfig] = useState<{
    field?: string
    order?: 'asc' | 'desc'
  }>({})

  const [isInitialized, setIsInitialized] = useState(false)
  //  const [tableFieldSettings, setTableFieldSettings] = useState<UserTableSetting[] | null>(null);
  // const [tableLoading, setTableLoading] = useState(false);

  const [tableFieldSettings, setTableFieldSettings] = useState<UserTableSettings[] | null>(null)

  const {
    data,
    setData,
    loading: tableLoading,
    setLoading: setTableLoading,
  } = useDataTableState([])

  const [dynamicTableConfig, setDynamicTableConfig] = useState<{
    columnHeadings: string[]
    columnIndices: string[]
    colsAlign: string[]
    tableSettings: Array<{ blockchk: boolean }>
    defColSort: number
    defColSortType: string
    colsCnt: string[]
    formatter: string[]
  } | null>(null)

  const processedTableData = useMemo(() => {
    // debugger;
    if (!data || data.length === 0) {
      return []
    }
    const processedData = data.map((task: any, index: number) => ({
      ...task,
      id: task.taskId || index,
      key: `${task.taskId?.toString() || 'no-id'}-${index}`,
      taskDate_sort: task.taskDate ? moment(task.taskDate).valueOf() : 0,
      _rowIndex: index,
    }))
    return processedData
  }, [data])

  // Assuming createAuthHeaders and API_CONFIG are available in scope.

  const fetchUserSettings = async (tableId: string) => {
    // debugger;
    setTableLoading(true)
    try {
      const clienttimezone = encodeURIComponent(moment.tz.guess())

      // The gettblfields API uses query parameters, not a POST body structure like addTask
      // so we don't need the URLSearchParams encoding here. We just need the headers and credentials.

      const rnd = Date.now()
      // The URL remains a GET request with query params
      const url = `${API_CONFIG.baseUrl}/tableconfig/gettblfields?tblid=${tableId}&rnd=${rnd}`

      const response = await fetch(url, {
        method: 'GET',
        headers: createAuthHeaders({
          Accept: 'application/json, text/javascript, */*; q=0.01',
        }),
        credentials: 'include',
      })

      if (!response.ok) throw new Error('Failed to fetch user settings')

      const rawSettings: TableSettingsResponse = await response.json()

      const parsedColumnDefs: UserTableSetting[] = JSON.parse(rawSettings.settings.column_def)

      setTableFieldSettings(parsedColumnDefs)
    } catch (error) {
      console.error('Error fetching table field settings:', error)
    }
  }

  useEffect(() => {
    const currentTableId = 'dataTable_task_expanded'
    fetchUserSettings(currentTableId)
  }, [])

  // const [processedTableData, setProcessedTableData] = useState<any[]>([]);

  const fetchTaskData = async () => {
    setTableLoading(true)

    try {
      const clienttimezone = encodeURIComponent(moment.tz.guess())

      // Define the payload using the new interface
      const payloadObj: TaskPayload = {
        top: 'collapsed',
        action: 'expanded',
        clienttimezone: clienttimezone,
        enablelink: true,
        start: 0,
        length: 50,
        search: { value: '', regex: false },
        order: [{ column: 11, dir: 'desc', name: 'taskDate' }],
        columns: [
          {
            data: 'action',
            name: 'Action',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'taskName',
            name: 'Task Name',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'taskType',
            name: 'Task Type',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'taskAssignedName',
            name: 'Assignee',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'contactId',
            name: 'Contact Id',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'contactName',
            name: 'Contact Name',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'accountId',
            name: 'Account Id',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'accountName',
            name: 'Account Name',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'taskId',
            name: 'Task Id',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'assignBy',
            name: 'Assign By',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'taskComment',
            name: 'Task Comments',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'taskDate',
            name: 'Task Due Date',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
          {
            data: 'taskStatus',
            name: 'Status',
            searchable: true,
            orderable: true,
            search: { value: '', regex: false },
          },
        ],
      }

      const encoded = new URLSearchParams({ data: JSON.stringify(payloadObj) }).toString()
      // ... (rest of your fetch logic) ...

      const response = await fetch(`${API_CONFIG.baseUrl}/task/getTaskTable`, {
        method: 'POST',
        headers: createAuthHeaders({
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
          Accept: 'application/json, text/javascript, */*; q=0.01',
        }),
        body: encoded,
        credentials: 'include',
      })

      if (!response.ok) throw new Error('Network response was not ok')

      const rawApiData: DynamicTableConfigResponse = await response.json()
      setData(rawApiData.data)
    } catch (error) {
      console.error('Failed to fetch task table data:', error)
      toast({ title: 'Error fetching data', variant: 'destructive' })
    } finally {
      setTableLoading(false)
    }
  }

  useEffect(() => {
    // This calls the function immediately when the page loads
    fetchTaskData()
  }, [])



  const handleCloseModal = () => {
    setModalOpen(false)
    resetForm()
    setEditTask(null)
  }



  const handleConfirmDelete = async () => {
    if (taskToDeleteData) {
      setIsDeleteModalOpen(false)
      await deleteTask(taskToDeleteData.taskId, taskToDeleteData.taskData)
      setTaskToDeleteData(null)
    }
  }

  const closeDeleteModal = () => {
    setIsDeleteModalOpen(false)
    setTaskToDeleteData(null)
  }

  const DeleteConfirmationModal = ({ isOpen, onClose, onConfirm }) => {
    if (!isOpen) return null

    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
        <div className="w-full max-w-sm rounded-lg bg-white p-6 shadow-xl">
          <h2 className="mb-4 text-xl font-bold text-gray-800">Delete Task</h2>
          <p className="mb-6 text-gray-600">Are you sure you want to delete this task?</p>
          <div className="flex justify-end gap-3">
            <button
              onClick={onClose}
              className="rounded bg-gray-200 px-4 py-2 text-gray-800 hover:bg-gray-300"
            >
              No
            </button>
            <button
              onClick={onConfirm}
              className="rounded bg-red-600 px-4 py-2 text-white hover:bg-red-700"
            >
              Yes
            </button>
          </div>
        </div>
      </div>
    )
  }

  // const openViewModal = (task: TaskItem) => {
  //   setSelectedTask(task)
  //   setIsViewModalOpen(true)
  // }
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQuery(e.target.value)
    if (!e.target.value) {
      setIsOpen(false)
    } else {
      setIsOpen(true)
    }
    setSelectedIndex(-1)
    if (!isModalOpen) setModalOpen(true)
  }

  // const closeViewModal = () => {
  //   setIsViewModalOpen(false)
  //   setSelectedTask(null)
  // }

  // interface ViewTaskModalProps {
  //   isOpen: boolean
  //   onClose: () => void
  //   task: TaskItem
  // }

  // const ViewTaskModal: React.FC<ViewTaskModalProps> = ({ isOpen, onClose, task }) => {
  //   return (
  //     <Dialog.Root open={isOpen} onOpenChange={onClose}>
  //       <Dialog.Portal>
  //         <Dialog.Overlay className="fixed inset-0 z-40 bg-black/40 backdrop-blur-sm" />

  //         <Dialog.Content className="fixed left-1/2 top-1/2 z-50 w-full max-w-lg -translate-x-1/2 -translate-y-1/2 rounded-lg bg-white p-6 shadow-xl">
  //           <Dialog.Title className="mb-4 text-2xl font-bold">
  //             Task Details: {task.taskName}
  //           </Dialog.Title>

  //           <div className="space-y-3">
  //             <p>
  //               <strong>Status:</strong> {task.taskStatus}
  //             </p>
  //             <p>
  //               <strong>Due Date:</strong>
  //               {task.taskDate && new Date(task.taskDate).toLocaleString()}
  //             </p>
  //             <p>
  //               <strong>Assignee:</strong> {task.taskAssignedName}
  //             </p>
  //             <p>
  //               <strong>Task Type:</strong> {task.taskType}
  //             </p>
  //             <p>
  //               <strong>Description:</strong> {task.taskComment}
  //             </p>
  //             <p>
  //               <strong>Account:</strong> {task.accountName?.join(', ')}
  //             </p>
  //             <p>
  //               <strong>ContactName:</strong> {task.contactName?.join(', ')}
  //             </p>
  //           </div>

  //           <div className="mt-6 flex justify-end">
  //             <Dialog.Close asChild>
  //               <button onClick={onClose} className="rounded bg-gray-300 px-4 py-2">
  //                 Close
  //               </button>
  //             </Dialog.Close>
  //           </div>
  //         </Dialog.Content>
  //       </Dialog.Portal>
  //     </Dialog.Root>
  //   )
  // }

  const normalizeToArray = (data: any) => (Array.isArray(data) ? data : data ? [data] : [])

  // To fetch tasks from API
  async function fetchTasks() {
    setLoading(true)
    try {
      const summaryFilter = prismStorage.get('summaryFilter') || JSON.stringify({ filter: [] })
      const body = new URLSearchParams({ summaryFilter }).toString()
      const res = await fetch(`${API_CONFIG.baseUrl}/task/getTask`, {
        method: 'POST',
        headers: createAuthHeaders({
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
          Accept: 'application/json, text/javascript, */*; q=0.01',
        }),
        body,
        credentials: 'include',
      })
      const data = await res.json()
      if (data?.status === 1) {
        setTasks(Array.isArray(data.data) ? data.data : [])

        const rawTasks = Array.isArray(data.data) ? data.data : []
        const normalizedTasks = rawTasks.map((task: any) => {
          const contactIds = task.contactList
            ? task.contactList.map((contactItem: any) => contactItem.contact_id)
            : []

          const contactNames = task.contactList
            ? task.contactList.map((contactItem: any) => contactItem.contact_name)
            : []
          const accountNames = task.contactList
            ? task.contactList.map((contactItem: any) => contactItem.account_name)
            : []
          return {
            ...task,

            contacts: contactIds,
            contactName: contactNames,
            accountName: accountNames,
          }
        })

        setTasks(normalizedTasks)
      } else {
        setTasks([])
      }
    } catch (err) {
      console.error('fetchTasks error', err)
      toast({ title: 'Error', description: 'Failed to fetch tasks' })
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    if (isModalOpen) {
      fetchTasks()
    }
  }, [isModalOpen])

  const fetchTaskTypes = async () => {
    // debugger;
    setIsLoadingOptions(true)
    try {
      const payload = {
        type: 'tasktype',
      }
      const encoded = new URLSearchParams(payload).toString()
      const response = await fetch(`${API_CONFIG.baseUrl}/task/gettaskdetails`, {
        method: 'POST',
        headers: createAuthHeaders({
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
          Accept: 'application/json, text/javascript, */*; q=0.01',
        }),
        body: encoded,
        credentials: 'include',
      })

      if (!response.ok) {
        throw new Error('Network response was not ok')
      }

      const data = await response.json()

      if (data.status === 1 && Array.isArray(data.data)) {
        setTaskOptions(data.data)
      } else {
        setTaskOptions([])
      }
    } catch (error) {
      console.error('Failed to fetch task types:', error)
    } finally {
      setIsLoadingOptions(false)
    }
  }

  const fetchStatusTypes = async () => {
    setIsLoadingStatusOptions(true)
    try {
      const payload = { type: 'status' }
      const encoded = new URLSearchParams(payload).toString()
      const response = await fetch(`${API_CONFIG.baseUrl}/task/gettaskdetails`, {
        method: 'POST',
        headers: createAuthHeaders({
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
          Accept: 'application/json, text/javascript, */*; q=0.01',
        }),
        body: encoded,
        credentials: 'include',
      })

      if (!response.ok) {
        throw new Error('Network response was not ok')
      }

      const data = await response.json()
      if (data.status === 1 && Array.isArray(data.data)) {
        setStatusOptions(data.data)
      } else {
        setStatusOptions([])
      }
    } catch (error) {
      console.error('Failed to fetch status types:', error)
    } finally {
      setIsLoadingStatusOptions(false)
    }
  }

  useEffect(() => {
    fetchTaskTypes()
    fetchStatusTypes()
  }, [])

  // To fetch full task details by ID

  async function fetchTaskDetails(taskId: string) {
    // debugger
    try {
      const body = new URLSearchParams({ taskId }).toString()
      const res = await fetch(`${API_CONFIG.baseUrl}/task/getTask`, {
        method: 'POST',
        headers: createAuthHeaders({
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        }),
        body,
        credentials: 'include',
      })
      const data = await res.json()
      if (data?.status === 1) {
        if (Array.isArray(data.data) && data.data.length > 0) return data.data[0]
        return data.data || null
      }
      return null
    } catch (err) {
      return null
    }
  }

  useEffect(() => {
    // debugger;
    const initializeComponent = async () => {
      try {
        const tableConfig = await loadTableSettings()

        if (tableConfig) {
          await loadTableFields()
        }

        // If we have table config and component is not initialized, trigger initial data load
        if (tableConfig && !isInitialized) {
          setIsInitialized(true)
        }
      } catch (error) {
        // Silently handle initialization errors to prevent app crash
        // Silently handle initialization errors
      }
    }

    // Note: Styles are now handled via Tailwind CSS classes in the JSX instead of direct DOM manipulation

    // Modern utility functions using React patterns (instead of direct window manipulation)
    const utilityFunctions = {
      showNotification: (message: string) => {
        toast({
          title: 'Navigation',
          description: message,
        })
      },
    }

    // Legacy compatibility - only set window functions if needed for backwards compatibility
    if (typeof window !== 'undefined') {
      const globalWindow = window as unknown as Record<string, unknown>

      // Expose utility functions for legacy code if needed
      if (!globalWindow.showToast) {
        globalWindow.showToast = utilityFunctions.showNotification
      }
    }

    // Note: Styles are now handled via Tailwind CSS classes instead of direct DOM injection
    initializeComponent()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []) // Empty dependency array - only run on mount

  const loadTableSettings = useCallback(async () => {
    // debugger;
    try {
      // Use enhanced ReactUtils.fetchPost with URL-encoded content-type
      const response = await ReactUtils.fetchPost(
        `${API_CONFIG.baseUrl}/tableconfig/gettablesetting`,
        {
          moduletype: 'taskdetails',
          rpttype: 'gettaskmodule',
          rnd: moment().valueOf().toString(),
        },
        {
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        }
      )

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const result = await response.json()
      if (result) {
        // Extract dynamic table configuration from response
        const config = {
          columnHeadings: result.title || [],
          columnIndices: result.cols || [],
          colsAlign: result.colsAlign || [],
          tableSettings: result.table_settings || [],
          defColSort: result.defColSort || 0,
          defColSortType: result.defColSortType || 'asc',
          colsCnt: result.colsCnt || [],
          formatter: result.formatter || [],
        }

        setDynamicTableConfig(config)
        return config
      }
      throw new Error('Failed to load table settings')
    } catch (error) {
      // Silently handle table settings error to prevent UI disruption
      return null
    }
  }, [])

  const loadTableFields = useCallback(async () => {
    try {
      // Use common function from datatable-utils instead of manual API call
      // Match jQuery implementation: thisRepId + 'closedDealTable'
      const tableId = `dataTable_task_expanded`
      const result = await DrawDataTableCore.loadTableFields(tableId)

      if (result.success && result.settings) {
        // Store table field settings to apply column visibility
        setTableFieldSettings(result.settings)
        return result.settings
      }

      // If no settings found, create default settings (show first 3 columns)
      if (dynamicTableConfig?.columnIndices) {
        const defaultSettings: UserTableSettings[] = dynamicTableConfig.columnIndices.map(
          (colIndex, index) => ({
            data: colIndex,
            checked: index < 3, // Show first 3 columns by default (matching jQuery behavior)
          })
        )
        setTableFieldSettings(defaultSettings)       
        return defaultSettings
      }

      throw new Error('Failed to load table fields')
    } catch (error) {
      // Silently handle table fields error to prevent UI disruption
      return null
    }
  }, [dynamicTableConfig])

  useEffect(() => {
    fetchTasks()
  }, [])

  useEffect(() => {
    if (assigneeList.length > 0) {
      setAssignedTo(assigneeList[0]?.value || '')
    } else {
      setAssignedTo('')
    }
  }, [assigneeList, setAssignedTo])

  // Fetch assignees based on query
  useEffect(() => {
    if (assigneeList.length > 0) {
      setAssigneeResults([])
      return
    }

    const timer = setTimeout(async () => {
      if (!query.trim()) {
        setAssigneeResults([])
        return
      }

      setLoadingSearch(true)

      const payload = {
        filtertype: 'employee',
        filterrpttype: 'Outlook',
        showuser: true,
        searchtext: query,
      }

      const queryString = new URLSearchParams(payload).toString()

      const requestUrl = `${API_CONFIG.baseUrl}/userconfig/searchfilters?${queryString}`

      try {
        const res = await fetch(requestUrl, {
          method: 'GET',
          headers: createAuthHeaders({
            Accept: 'application/json, text/javascript, */*; q=0.01',
          }),
          credentials: 'include',
        })

        const data: AssigneeOption[] = await res.json()

        if (Array.isArray(data)) {
          setAssigneeResults(data)
        } else {
          setAssigneeResults([])
        }
      } catch (err) {
        console.error('Fetch assignee error:', err)
        setAssigneeResults([])
      } finally {
        setLoadingSearch(false)
      }
    }, 300)

    return () => clearTimeout(timer)
  }, [query, assigneeList])

  // fetch contacts based on contactQuery
  useEffect(() => {
    const timer = setTimeout(async () => {
      if (!contactQuery.trim()) {
        setContactResults([])
        return
      }

      setLoadingContacts(true)
      const queryString = new URLSearchParams({
        filtertype: 'contact',
        restype: 'Detailed',
        searchtext: contactQuery,
      }).toString()

      const requestUrl = `${API_CONFIG.baseUrl}/userconfig/searchfilters?${queryString}`

      try {
        const res = await fetch(requestUrl, {
          method: 'GET',
          headers: createAuthHeaders({
            Accept: 'application/json, text/javascript, */*; q=0.01',
          }),
          credentials: 'include',
        })

        const data: ContactOption[] = await res.json()

        if (Array.isArray(data)) {
          setContactResults(data)
        } else {
          setContactResults([])
        }
      } catch (err) {
        console.error('Fetch contact error:', err)
        setContactResults([])
      } finally {
        setLoadingContacts(false)
      }
    }, 300)

    return () => clearTimeout(timer)
  }, [contactQuery])

  // Handle contact selection
  const handleContactSelect = (contact: ContactOption) => {
    if (
      typeof contact.value !== 'string' ||
      typeof contact.text !== 'string' ||
      !contact.value ||
      !contact.text
    ) {
      console.error('Invalid contact data received:', contact)
      return
    }
    if (!contacts.includes(contact.value)) {
      setContacts((prev) => [...prev, contact.value!])

      setContactNames((prev) => [...prev, contact.text!])
    }
    setContactQuery('')
    setIsContactResultsOpen(false)
  }

  const handleContactInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setContactQuery(e.target.value)
    setIsContactResultsOpen(true)
  }

  const removeContact = (contactId: string) => {
    setContacts((prev) => prev.filter((id) => id !== contactId))
    setContactNames((prev) => prev.filter((name, index) => contacts[index] !== contactId))
  }

  const handleAssigneeSelect = (assignee: AssigneeOption) => {
    // Enforce single selection: replace the current list with only the new selection
    setAssigneeList([{ value: assignee.value, text: assignee.text }])

    // Clear search related states
    setQuery('')
    setAssigneeResults([])
    setIsOpen(false)
  }

  const handleRemoveAssignee = (assigneeId: string | number) => {
    setAssigneeList([])
  }

  // Add new task
  async function handleAddTask() {
    try {
      const currentAssigneeId = assigneeList.length > 0 ? assigneeList[0].value : ''
      const isEmpty = (value: any) =>
        value === null ||
        value === undefined ||
        (typeof value === 'string' && value.trim() === '') ||
        (Array.isArray(value) && value.length === 0)

      const mandatoryFields = [
        { value: currentAssigneeId, name: 'Assignee' },
        { value: subject, name: 'Subject' },
        { value: dueDate, name: 'Due Date' },
        { value: timeStr, name: 'Time' },
        { value: taskType, name: 'Task Type' },
        { value: status, name: 'Status' },
        { value: contacts, name: 'Contacts' },
      ]

      const missingField = mandatoryFields.find((field) => isEmpty(field.value))

      if (missingField) {
        toast({
          title: 'Validation Error',
          description: `The mandatory field "${missingField.name}" is missing. Please fill out all required fields.`,
        })
        return
      }

      // if (!assignedToIds) {
      //   toast({ title: 'Validation', description: 'Assignee required' })
      //   return
      // }
      if (!subject.trim()) {
        toast({ title: 'Validation', description: 'Subject required' })
        return
      }
      const clienttimezone = encodeURIComponent(moment.tz.guess())

      const rawTaskDate = dueDate

      const formattedDateTime = rawTaskDate
        ? moment(rawTaskDate, 'YYYY-MM-DD HH:mm:ss.S').format('YYYY-MM-DD HH:mm:ss')
        : ''

      const formattedDueTime = rawTaskDate
        ? moment(rawTaskDate, 'YYYY-MM-DD HH:mm:ss.S').format('HH:mm')
        : ''
      const sanitizedContacts = contacts.filter((id) => id != null && id !== '')
      const sanitizedContactNames = contactNames.filter((name) => name != null && name !== '')

      const payloadObj = {
        subject,
        dueDate: formattedDateTime,
        dueTime: formattedDueTime,
        contacts: sanitizedContacts,
        contactName: sanitizedContactNames,
        assignedTo: currentAssigneeId,
        clienttimezone,
        status,
        taskType,
        taskComments: description,
        module_name: 'Task',
        action: 'Save',
      }
      const encoded = new URLSearchParams({ data: JSON.stringify(payloadObj) }).toString()
      const res = await fetch(`${API_CONFIG.baseUrl}/task/addTask`, {
        method: 'POST',
        headers: createAuthHeaders({
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
          Accept: 'application/json, text/javascript, */*; q=0.01',
        }),
        body: encoded,
        credentials: 'include',
      })
      const data = await res.json()
      if (data?.status === 1) {
        toast({ title: 'Success', description: 'Task Added Successfully' })
        setModalOpen(false)
        resetForm()
        fetchTasks()
      } else {
        toast({ title: 'Error', description: data?.message || 'Failed to add task' })
      }
    } catch (err) {
      console.error('handleAddTask', err)
      toast({ title: 'Error', description: 'Failed to add task' })
    }
  }

  async function handleUpdateTask() {
    // debugger;
    try {
      if (!editTask) return
      const rawTaskDate = dueDate
      const clienttimezone = encodeURIComponent(moment.tz.guess())
      const formattedDateTime = rawTaskDate
        ? moment(rawTaskDate, 'YYYY-MM-DD HH:mm:ss.S').format('YYYY-MM-DD HH:mm:ss')
        : ''
      const formattedDueTime = rawTaskDate
        ? moment(rawTaskDate, 'YYYY-MM-DD HH:mm:ss.S').format('HH:mm')
        : ''

      const payloadObj = {
        subject,
        dueDate: formattedDateTime,
        dueTime: formattedDueTime,
        contacts,
        contactName: contactNames,
        assignedTo: assignedToIds,
        clienttimezone,
        status,
        taskType,
        taskComments: description,
        module_name: 'Task',
        action: 'Update',
        taskId: editTask.taskId,
      }
      const encoded = new URLSearchParams({ data: JSON.stringify(payloadObj) }).toString()
      const res = await fetch(`${API_CONFIG.baseUrl}/task/addTask`, {
        method: 'POST',
        headers: createAuthHeaders({
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
          Accept: 'application/json, text/javascript, */*; q=0.01',
        }),
        body: encoded,
        credentials: 'include',
      })
      const data = await res.json()
      if (data?.status === 1) {
        toast({ title: 'Success', description: 'Task Updated Successfully' })
        setModalOpen(false)
        setEditTask(null)
        resetForm()
        fetchTasks()
      } else {
        toast({ title: 'Error', description: data?.message || 'Failed to update task' })
      }
    } catch (err) {
      console.error('handleUpdateTask', err)
      toast({ title: 'Error', description: 'Failed to update task' })
    }
  }

  // To edit existing task
  const openEditModal = useCallback(
    async (task: TaskItem) => {
      let tdata: any = task
      const missingContactsStructured =
        !tdata.contacts ||
        (Array.isArray(tdata.contacts) && tdata.contacts.length === 0) ||
        !tdata.contactList ||
        (Array.isArray(tdata.contactList) && tdata.contactList.length === 0)

      const missingName = !tdata.taskName && !tdata.subject

      if ((missingContactsStructured || missingName) && tdata.taskId) {
        const full = await fetchTaskDetails(tdata.taskId)
        if (full) tdata = { ...tdata, ...full }
      }

      setEditTask(tdata)
      setSubject(tdata.taskName || tdata.subject || '')
      setDescription(tdata.taskComment || tdata.taskComments || '')
      const assignedId = tdata.taskAssignedId || tdata.assignedTo || ''
      const assignedName = tdata.taskAssignedName || ''
      setAssignedTo(assignedId)
      setAssignedToNames(assignedName)

      if (assignedId && assignedName) {
        setAssigneeList([{ value: assignedId, text: assignedName }])
      } else {
        setAssigneeList([])
        console.warn('Assignee data was missing, assignee list set to empty.')
      }

      setQuery('')
      setTaskType(tdata.taskType || '')
      setStatus(tdata.taskStatus || '')

      if (tdata.taskDate) {
        const iso = String(tdata.taskDate).replace(' ', 'T')
        const dt = new Date(iso)
        if (!isNaN(dt.getTime())) {
          setDueDate(dt)
          const hh = dt.getHours().toString().padStart(2, '0')
          const mm = dt.getMinutes().toString().padStart(2, '0')
          setTimeStr(`${hh}:${mm}`)
        } else {
          setDueDate(new Date())
          setTimeStr('10:00')
        }
      } else {
        setDueDate(new Date())
        setTimeStr('10:00')
      }

      let contactIds: string[] = []
      let contactNamesForAPI: string[] = []

      if (tdata.contactList && Array.isArray(tdata.contactList) && tdata.contactList.length > 0) {
        contactIds = tdata.contactList.map((c) => c.contact_id)
        contactNamesForAPI = tdata.contactList.map((c) => c.contact_name)
      }
      // Fallback to the 'contacts' array if 'contactList' wasn't used (e.g., if it's the *only* thing the full fetch returns)
      else if (Array.isArray(tdata.contacts) && tdata.contacts.length > 0) {
        contactIds = tdata.contacts
        contactNamesForAPI = Array.isArray(tdata.contactName) ? tdata.contactName : []
      }

      // If the above processing didn't work, we are back to parsing the single string summary data
      if (contactIds.length === 0 && tdata.contactId && typeof tdata.contactId === 'string') {
        contactIds = [tdata.contactId]
      }

      setEditTask(tdata)
      setContacts(contactIds)
      setContactNames(contactNamesForAPI)
      setModalOpen(true)
    },
    [fetchTaskDetails, setEditTask, setSubject, setContacts, setContactNames, setModalOpen]
  )

  // To delete a task
  async function deleteTask(taskId: string, originalTaskData: any) {
    try {
      const clienttimezone = encodeURIComponent(moment.tz.guess())

      const rawTaskDate = originalTaskData?.taskDate

      const formattedDateTime = rawTaskDate
        ? moment(rawTaskDate, 'YYYY-MM-DD HH:mm:ss.S').format('YYYY-MM-DD HH:mm:ss')
        : ''

      const formattedDueTime = rawTaskDate
        ? moment(rawTaskDate, 'YYYY-MM-DD HH:mm:ss.S').format('HH:mm')
        : ''

      const taskContactNames = normalizeToArray(originalTaskData?.contactName)

      const payload = {
        subject: originalTaskData?.subject || originalTaskData?.taskName || subject,
        dueDate: formattedDateTime,
        dueTime: formattedDueTime,
        contacts: normalizeToArray(originalTaskData?.contacts),
        contactName: taskContactNames,
        assignedTo: originalTaskData?.taskAssignedId || originalTaskData?.assignedTo || '',
        clienttimezone,
        status: 'Dismiss',
        taskType: originalTaskData?.taskType || '',
        taskComments:
          originalTaskData?.taskComments || originalTaskData?.taskComment || description,
        module_name: 'Task',
        action: 'Dismiss',
        taskId: taskId,
      }
      const encoded = new URLSearchParams({ data: JSON.stringify(payload) }).toString()
      const res = await fetch(`${API_CONFIG.baseUrl}/task/addTask`, {
        method: 'POST',
        headers: createAuthHeaders({
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
          Accept: 'application/json, text/javascript, */*; q=0.01',
        }),
        body: encoded,
        credentials: 'include',
      })
      const data = await res.json()

      if (data?.status === 1) {
        toast({ title: 'Deleted', description: 'Task Deleted Successfully' })
        fetchTasks()
      } else {
        toast({ title: 'Error', description: data?.message || 'Delete failed' })
      }
    } catch (err) {
      console.error('deleteTask', err)
      toast({ title: 'Error', description: 'Delete failed' })
    }
  }

  // Reset form fields
  function resetForm() {
    setSubject('')
    setAssignedTo('')
    setAssignedToNames('')
    setAssigneeList([])

    setTaskType('')
    setStatus('')
    setContacts([])
    setContactNames([])
    setDescription('')

    setTimeStr('')

    setQuery('')
    setAssigneeResults([])
    setContactQuery('')
    setContactResults([])
    setAssignedTo('')
    setContacts([])
    setContactNames([])

    setDueDate(new Date())
  }

  // Calculate time data for due date
  const calcTimeData = (due: string | undefined) => {
    if (!due) return null

    const dueDate = new Date(due)
    const now = new Date()
    const diffMs = dueDate.getTime() - now.getTime()

    const isOverdue = diffMs < 0
    const absDiffMs = Math.abs(diffMs)

    const days = Math.floor(absDiffMs / 86400000)
    const hours = Math.floor((absDiffMs % 86400000) / 3600000)
    const mins = Math.floor(((absDiffMs % 86400000) % 3600000) / 60000)

    let timeDiffText
    if (days > 0) timeDiffText = `${days} Day(s)`
    else if (hours > 0) timeDiffText = `${hours} Hour(s)`
    else if (mins > 0) timeDiffText = `${mins} Min(s)`
    else timeDiffText = '0 Min(s)'

    const label = isOverdue ? 'Over Due' : 'Time To Complete'

    const statusClass = isOverdue ? 'bg-red-500' : 'bg-blue-500'

    return {
      text: timeDiffText,
      fullText: `${timeDiffText} ${label}`,
      statusClass: statusClass,
    }
  }
  const handleDeleteClick = (taskId, taskData) => {
    setTaskToDeleteData({ taskId, taskData })
    setIsDeleteModalOpen(true)
  }

  const modernDataTableConfig = useMemo(() => {
    // Check if both main configuration and user settings have loaded
    if (!dynamicTableConfig || !tableFieldSettings) {
      return null
    }

    const { columnHeadings, columnIndices, colsAlign, tableSettings, colsCnt } = dynamicTableConfig

    const columns = columnHeadings.map((heading, index) => {
      const columnIndex = columnIndices[index]
      const alignment = colsAlign[index] || 'left'
      const isNumberFormat = colsCnt.includes(index.toString())
      const isDefault = tableSettings[index]?.blockchk || false

      const calculatedWidth = isNumberFormat
        ? 130
        : heading.toLowerCase().includes('name') ||
            heading.toLowerCase().includes('client') ||
            heading.toLowerCase().includes('account')
          ? 300
          : 150

      // *** Check if the current column is the 'Action' column ***
      const isActionColumn = columnIndex === 'action' || heading.toLowerCase() === 'action'

      return {
        key: columnIndex || `col_${index}`,
        title: heading,
        dataIndex: columnIndex,
        width: `${calculatedWidth}px`,

        render: (value: unknown, record: unknown, _index?: number) => {
          const taskRecord = record as TaskItem

          if (isActionColumn) {
            return (
              <div className="mt-2 flex gap-3">
                <button
                  className="p-2 text-yellow-600 hover:text-yellow-800"
                  onClick={() => openEditModal(taskRecord)}
                  title="Edit Task"
                >
                  <PencilIcon className="h-5 w-5" />
                </button>

                <button
                  className="p-2 text-red-600 hover:text-red-800"
                  onClick={() => handleDeleteClick(taskRecord.taskId, taskRecord)}
                  title="Delete Task"
                >
                  <TrashIcon className="h-5 w-5" />
                </button>
              </div>
            )
          }

          if (isNumberFormat && value !== null && value !== undefined) {
            const numValue = typeof value === 'number' ? value : parseFloat(String(value))
            if (!isNaN(numValue)) {
              return (
                <span className={numValue < 0 ? 'text-red-600' : ''}>
                  {DataTableFormatters.formatCurrency(numValue)}
                </span>
              )
            }
          }

          if (columnIndex === 'dealdate' && value) {
            return moment(String(value)).format('MM/DD/YYYY')
          }

          return String(value || '')
        },
        align: (isActionColumn ? 'center' : alignment) as 'left' | 'center' | 'right', // Center align action column
        sorter: (a: unknown, b: unknown) => {
          const recordA = a as Record<string, unknown>
          const recordB = b as Record<string, unknown>
          const fieldKey = columnIndex || `col_${index}`
          const aVal = recordA[fieldKey]
          const bVal = recordB[fieldKey]

          if (isNumberFormat) {
            const aNum = typeof aVal === 'number' ? aVal : parseFloat(String(aVal || 0))
            const bNum = typeof bVal === 'number' ? bNum : parseFloat(String(bNum || 0))
            return aNum - bNum
          }

          return String(aVal || '').localeCompare(String(bVal || ''))
        },
        ellipsis: true,
        responsive:
          heading.toLowerCase().includes('name') ||
          heading.toLowerCase().includes('client') ||
          heading.toLowerCase().includes('ticker') ||
          heading.toLowerCase().includes('deal') ||
          isActionColumn // Ensure action column is always visible
            ? ['xs', 'sm', 'md', 'lg', 'xl']
            : ['sm', 'md', 'lg', 'xl'],
        visible: tableFieldSettings
          ? tableFieldSettings.find((setting) => setting.data === columnIndex)?.checked !== false
          : isDefault !== false,
      }
    })

    return {
      columns,
      tableId: `dataTable_topten_client_collapsed`,
      scrollConfig: {
        x: 'max-content',
        y: 'calc(100vh - 300px)',
      },
      pagination: {
        enabled: false,
        pageSize: -1,
      },
      sorting: {
        enabled: true,
        defaultSort: dynamicTableConfig.defColSort
          ? {
              field: columnIndices[dynamicTableConfig.defColSort],
              order: dynamicTableConfig.defColSortType as 'asc' | 'desc',
            }
          : undefined,
      },
      export: {
        enabled: true,
        formats: ['csv', 'excel'] as Array<'csv' | 'excel'>,
        filename: 'closed_deals',
      },
      selection: {
        enabled: false,
      },
      responsive: true,
      stickyHeader: true,
      loading: isLoading || tableLoading,
    }
  }, [dynamicTableConfig, isLoading, tableLoading, tableFieldSettings]) // Add dependencies

  return (
    <div className="p-5">
      <div className="mb-4 flex justify-end">
        <button
          onClick={() => {
            setEditTask(null)
            resetForm()
            setModalOpen(true)
          }}
          className="rounded bg-blue-600 px-6 py-2 text-white shadow hover:bg-blue-700"
          title="Add Task"
        >
          Add
        </button>
      </div>

      <div className=""></div>
      {modernDataTableConfig ? (
        <div className="w-full overflow-hidden">
          <DataTable
            id="dataTable_topten_client_collapsed"
            columns={modernDataTableConfig.columns}
            dataSource={processedTableData}
            loading={modernDataTableConfig.loading}
            pagination={{
              pageSize: 50,
              pageSizeOptions: ['25', '50', '100', '200', '500'],
              showSizeChanger: true,
              showTotal: (total: number, range: [number, number]) =>
                `${range[0]}-${range[1]} of ${total} Task`,
              onChange: (_page: number, _pageSize: number) => {
                // Handle pagination changes
              },
              onShowSizeChange: (_current: number, _size: number) => {
                // Handle page size changes
              },
            }}
            scroll={modernDataTableConfig.scrollConfig}
            size="middle"
            bordered={true}
            stickyHeader={modernDataTableConfig.stickyHeader}
            responsive={modernDataTableConfig.responsive}
            exportOptions={{
              enabled: true,
              formats: ['csv', 'excel', 'json'],
              filename: `task_datas_${moment().format('YYYY-MM-DD')}`,
              onExport: (format: string, data: unknown[]) => {
                // Custom export handling if needed
                toast({
                  title: 'Export Started',
                  description: `Exporting ${data.length} records as ${format.toUpperCase()}...`,
                })
              },
            }}
            columnSettings={{
              enabled: true,
              onColumnChange: async (visibleColumns: string[]) => {
                // Save column visibility preferences to backend
                const tableId = `dataTable_task_expanded`
                // console.log(tableId)
                const preferences = {
                  
                  tableId,
                  visibleColumns,
                  timestamp: Date.now(),
                }

                
                // Store in localStorage for immediate persistence
                try {
                  // console.log("Preferences",preferences);
                  localStorage.setItem(`dataTable_${tableId}_columns`, JSON.stringify(preferences))
                } catch (error) {
                  // Handle storage errors silently
                }

                // Save to backend - convert column visibility to UserTableSettings format
                try {
                  const userTableSettings =modernDataTableConfig?.columns.map((column) => ({
                      data: column.dataIndex || column.key,
                      checked: visibleColumns.includes(column.key),
                      title: column.title || '',
                      isDefault: false,
                      order: modernDataTableConfig.columns.indexOf(column) + 1,
                    })) || []
                    console.log(userTableSettings)

                  const success = await DataTableSettings.setTableSettings(
                    tableId,
                    userTableSettings,
                    {
                      setTblIdUser: false, 
                    }
                  )

                  if (success) {
                    console.log(userTableSettings);
                    toast({
                      title: 'Column Visibility Saved',
                      description: `${visibleColumns.length} columns visible - settings saved to server`,
                    })
                  } else {
                    toast({
                      title: 'Column Visibility Updated',
                      description: `${visibleColumns.length} columns visible - saved locally only`,
                      variant: 'destructive',
                    })
                  }
                } catch (error) {
                  // Fallback to local storage notification
                  toast({
                    title: 'Column Visibility Updated',
                    description: `${visibleColumns.length} columns visible - saved locally`,
                    variant: 'destructive',
                  })
                }
              },
            }}
            serverSide={false}
          />

          <div className="flex flex-col items-start justify-between gap-2 border-t border-gray-200 bg-gray-50 px-4 py-2 text-xs text-gray-600 sm:flex-row sm:items-center">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-4">
              <span>Showing {processedTableData.length} Tasks</span>
            </div>
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-4">
              {/* Use optional chaining on modernDataTableConfig when mapping columns for user settings */}
              {sortConfig.field && (
                <span className="text-green-600">
                  Sorted by {sortConfig.field} ({sortConfig.order})
                </span>
              )}
              <span className="text-xs">Last updated: {moment().format('HH:mm:ss')}</span>
            </div>
          </div>
        </div>
      ) : (
        <div className="flex items-center justify-center p-8">
          <div className="flex items-center space-x-2">
            <div className="h-6 w-6 animate-spin rounded-full border-b-2 border-blue-600"></div>
            <span className="text-gray-600">Loading table configuration...</span>
          </div>
        </div>
      )}

      {hasMoreTasks && (
        <div className="mt-4 text-center">
          <button
            onClick={() => setShowAllTasks(!showAllTasks)}
            className="mx-auto flex items-center rounded-lg bg-gray-200 px-4 py-2 text-gray-700 transition duration-150 hover:bg-gray-300"
          >
            {showAllTasks ? (
              <>
                Show Less <ChevronUpIcon className="ml-2 h-4 w-4" />
              </>
            ) : (
              <>
                More ... <ChevronDownIcon className="ml-2 h-4 w-4" />
              </>
            )}
          </button>
        </div>
      )}

      <DeleteConfirmationModal
        isOpen={isDeleteModalOpen}
        onClose={closeDeleteModal}
        onConfirm={handleConfirmDelete}
      />

      {isModalOpen && (
        <Dialog.Root open={isModalOpen} onOpenChange={handleCloseModal}>
          <Dialog.Portal>
            <Dialog.Overlay className="fixed inset-0 z-[9998] bg-black/40 backdrop-blur-sm" />

            <Dialog.Content className="fixed left-1/2 top-1/2 z-[9999] max-h-[90vh] w-[700px] -translate-x-1/2 -translate-y-1/2 overflow-y-auto rounded-lg bg-white p-5 shadow-xl">
              <Dialog.Close className="absolute right-3 top-3 text-gray-600 hover:text-black">
                X
              </Dialog.Close>

              <Dialog.Title className="mb-4 text-xl font-semibold">
                {editTask ? 'Update Task' : 'Add Task'}
              </Dialog.Title>

              <div className="space-y-4">
                <div>
                  <label className="mb-2 block text-sm font-medium">
                    Assign To (Choose ONLY ONE Employee As Assignee)
                    <span className="text-red-500">*</span>
                  </label>

                  <div className="relative flex max-h-28 min-h-[3rem] flex-wrap items-center gap-2 overflow-y-auto rounded-md border border-gray-300 bg-gray-50 p-2 focus-within:border-blue-500 focus-within:bg-white">
                    {assigneeList.map((assignee) => (
                      <span
                        key={assignee.value}
                        className="inline-flex max-w-[220px] items-center truncate rounded bg-blue-100 px-2.5 py-0.5 text-sm font-medium text-blue-800"
                      >
                        <span className="inline-block max-w-[180px] truncate">{assignee.text}</span>
                        <button
                          type="button"
                          onClick={() => handleRemoveAssignee(assignee.value ?? '')}
                          className="ml-1 text-blue-800 hover:text-blue-900 focus:outline-none"
                        >
                          &times;
                        </button>
                      </span>
                    ))}

                    <Input
                      ref={inputRef}
                      type="text"
                      placeholder="Search..."
                      value={query}
                      onChange={handleInputChange}
                      onFocus={() => setIsOpen(true)}
                      className="min-w-[120px] flex-1 border-none bg-transparent p-0 text-base focus:outline-none"
                    />
                  </div>

                  {isOpen && query.length > 0 && (
                    <ul className="absolute z-[10000] mt-1 max-h-40 w-[calc(100%-2.5rem)] overflow-auto rounded-md border border-gray-300 bg-white py-1 text-base shadow-lg">
                      {loadingSearch ? (
                        <li className="p-2 text-gray-700">Loading...</li>
                      ) : assigneeResults.length > 0 ? (
                        assigneeResults.map((assignee) => (
                          <li
                            key={assignee.value}
                            className="cursor-pointer p-2 hover:bg-blue-600 hover:text-white"
                            onClick={() => handleAssigneeSelect(assignee)}
                          >
                            {assignee.text}
                          </li>
                        ))
                      ) : (
                        assigneeList.length === 0 && (
                          <li className="p-2 text-gray-700">No results found</li>
                        )
                      )}
                    </ul>
                  )}
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="mb-1 block text-sm font-medium">
                      Due Date<span className="text-red-500">*</span>
                    </label>
                    <DatePicker
                      selected={dueDate}
                      onChange={(d: Date | null) => setDueDate(d)}
                      className="w-full rounded border border-gray-300 p-2"
                    />
                  </div>
                  <div>
                    <label className="mb-1 block text-sm font-medium">
                      Time<span className="text-red-500">*</span>
                    </label>
                    <TimePicker
                      onChange={setTimeStr}
                      value={timeStr}
                      format="h:mm a"
                      className="w-full rounded border border-gray-300 p-2"
                      clearIcon={null}
                    />
                  </div>
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="mb-1 block text-sm font-medium">
                      Task Type<span className="text-red-500">*</span>
                    </label>
                    <select
                      value={taskType}
                      onChange={(e) => setTaskType(e.target.value)}
                      className="w-full rounded border border-gray-300 p-2"
                      disabled={isLoadingOptions}
                    >
                      <option value="">
                        {isLoadingOptions ? '-- Loading --' : '-- Select --'}
                      </option>
                      {taskOptions.map((option) => (
                        <option key={option.value} value={option.value}>
                          {option.text}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div>
                    <label className="mb-1 block text-sm font-medium">
                      Status<span className="text-red-500">*</span>
                    </label>
                    <select
                      value={status}
                      onChange={(e) => setStatus(e.target.value)}
                      className="w-full rounded border border-gray-300 p-2"
                      disabled={isLoadingStatusOptions}
                    >
                      <option value="">
                        {isLoadingStatusOptions ? '-- Loading --' : '-- Select --'}
                      </option>
                      {statusOptions.map((option) => (
                        <option key={option.value} value={option.value}>
                          {option.text}
                        </option>
                      ))}
                    </select>
                  </div>
                </div>

                <div>
                  <label className="mb-1 block text-sm font-medium">
                    Subject<span className="text-red-500">*</span>
                  </label>
                  <input
                    type="text"
                    value={subject}
                    onChange={(e) => setSubject(e.target.value)}
                    className="w-full rounded border border-gray-300 p-2"
                    placeholder="Enter Subject..."
                  />
                </div>

                <div className="relative">
                  <label className="mb-2 block text-sm font-medium">
                    Contacts<span className="text-red-500">*</span>
                  </label>

                  <div className="relative flex max-h-28 min-h-[3rem] flex-wrap items-center gap-2 overflow-y-auto rounded-md border border-gray-300 bg-gray-50 p-2 focus-within:border-blue-500 focus-within:bg-white">
                    {contacts.map((contactId, index) => {
                      const name = contactNames[index]
                      if (!name) return null

                      return (
                        <span
                          key={contactId}
                          className="flex items-center rounded bg-blue-100 px-2.5 py-0.5 text-sm font-medium text-blue-800"
                        >
                          {name}
                          <button
                            type="button"
                            onClick={() => removeContact(contactId)}
                            className="ml-1 text-blue-800 hover:text-blue-900 focus:outline-none"
                          >
                            &times;
                          </button>
                        </span>
                      )
                    })}

                    <Input
                      type="text"
                      placeholder="Search and add contacts..."
                      value={contactQuery}
                      onChange={handleContactInputChange}
                      onFocus={() => setIsContactResultsOpen(true)}
                      className="min-w-[120px] flex-1 border-none bg-transparent p-0 text-base focus:outline-none"
                    />
                  </div>

                  {isContactResultsOpen &&
                    (contactQuery.length > 0 || contactResults.length > 0) && (
                      <ul className="absolute z-[10000] mt-1 max-h-40 w-[calc(100%-2.5rem)] overflow-auto rounded-md border border-gray-300 bg-white py-1 text-base shadow-lg">
                        {loadingContacts ? (
                          <li className="p-2 text-gray-700">Loading...</li>
                        ) : contactResults.length > 0 ? (
                          contactResults.map((contact) => (
                            <li
                              key={contact.value}
                              className="cursor-pointer p-2 hover:bg-blue-600 hover:text-white"
                              onClick={() => handleContactSelect(contact)}
                            >
                              {contact.text}
                            </li>
                          ))
                        ) : (
                          <li className="p-2 text-gray-700">No contacts found</li>
                        )}
                      </ul>
                    )}
                </div>

                <div>
                  <label className="mb-1 block text-sm font-medium">Description</label>
                  <textarea
                    value={description}
                    onChange={(e) => setDescription(e.target.value)}
                    className="w-full rounded border border-gray-300 p-2"
                    rows={3}
                    placeholder="Enter Description..."
                  />
                </div>
              </div>

              <div className="mt-6 flex justify-end gap-3">
                <button
                  onClick={handleCloseModal}
                  className="rounded border border-gray-300 bg-white px-4 py-2 text-gray-700 hover:bg-gray-50"
                >
                  Cancel
                </button>
                <button
                  onClick={editTask ? handleUpdateTask : handleAddTask}
                  className="rounded bg-blue-600 px-4 py-2 text-white hover:bg-blue-700"
                >
                  {editTask ? 'Update' : 'Save'}
                </button>
              </div>
            </Dialog.Content>
          </Dialog.Portal>
        </Dialog.Root>
      )}
    </div>
  )
}
